---
title: "Creating a catalogue of translatables"
output: rmarkdown::html_vignette
description: >
  Learn how pkgdown's automatic linking works, and how you can 
  customise it.
vignette: >
  %\VignetteIndexEntry{Creating a catalogue of translatables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Use case

* We want to create a catalogue (data frame)
* With all translatable texts of a survey and
* Ordered by `group_order` and `question_order`
* For groups it should contain
  * `group_name`
  * `description`
* For questions it should contain
  * `question`
  * `help`
  * Whether it is a sub-question (`parent_qid != 0`)
  * If it is a sub-question, `parent_qid` must be preserved in a way
* For list questions it should contain all answer options
  * `answerText`
  * `answerCode` must be preserved in a way
  * It must be connected to its question

The catalogue should then be sent to a translator who will return it with
replaced texts. Those texts should then be sent to the LimeSurvey application.

## Design

How could the catalogue look like?

| Text ID | Source text | Target text |
|---|---|---|
| `paste0()` | "A group title" | "Ein Gruppentitel" |
| â€¦ |  |  |

## Environment preparation

```{r}
if (!require("tidyverse")) install.packages("tidyverse")
library(tidyverse)

if (!require("LimeRick")) {
  if (!require("devtools")) install.packages("devtools")
  devtools::install_github("k127/LimeRick")
}
library(LimeRick)
```


## Set up survey ID and source language, get a session key

```{r}
# The ID of the to be translated survey
surveyID = "259165"

# Let's say that our translation workflow has English as the source language
lang = "en"

# Get a session key for our future requests
lsGetSessionKey()
```


## Get the group list

```{r}
# Note that the field group order has to be numerical for the arrangement to work
groups <- arrange(lsListGroups(surveyID = surveyID, setTypes = TRUE), group_order)
```


## Get the question list

```{r}
questions <- arrange(lsListQuestions(surveyID = surveyID, lang = lang,
                                     setTypes = TRUE), question_order)
```

# TODO suggest package "rapport"

## Read front / back matter from file

Set the path to front matter html files like that:
`options(front_matter_path = "./path/to/my/front/matter/files")`

```{r}

.front_matter <- list(
  welcome = read_file(paste(getOption("front_matter_path"), "welcome.html", sep = "/")),
  policy_label = read_file(paste(getOption("front_matter_path"), "survey_data_policy_label.html", sep = "/")),
  policy_notice = read_file(paste(getOption("front_matter_path"), "survey_data_policy_notice.html", sep = "/")))
```

## Iterate over groups, questions

```{r}
# TODO put functions here
```

```{r}
# Create an empty data frame
.key_text_id = "text_id"
.key_source_text = "source_text"
.key_target_text = "target_text"
.col_names = c(.key_text_id, .key_source_text, .key_target_text)
catalogue <- read.table(text = "",
                        colClasses = c("character", "character", "character"),
                        col.names = .col_names)

# add front matter
for (.front_matter_item_key in names(.front_matter)){
  .front_matter_item_value <- .front_matter[.front_matter_item_key]
  .df_row = data.frame(paste0("FRONTMATTER___", .front_matter_item_key), .front_matter_item_value, "")
  names(.df_row) = .col_names
  catalogue = rbind(catalogue, .df_row)
}

# TODO add back matter

for (.i in 1:nrow(groups)) {
  .gid = groups[.i,]$gid
  
  # add group_name to catalogue
  # TODO if source_text exists, only append text_id
  .group_name =  groups[.i,]$group_name
  if (trimws(.group_name) != "") {
    .df_row_group_name = data.frame(paste0("GID___", .gid, "___group_name"), .group_name, "")
    names(.df_row_group_name) = .col_names
    catalogue = rbind(catalogue, .df_row_group_name)
  }

  # add description to catalogue
  # TODO if source_text exists, only append text_id
  .group_description = groups[.i,]$description
  if (trimws(.group_description) != "") {
    .df_row_group_description = data.frame(paste0("GID___", .gid, "___description"), .group_description, "")
    names(.df_row_group_description) = .col_names
    catalogue = rbind(catalogue, .df_row_group_description)
  }

  .group_questions = arrange(filter(questions, gid == .gid, parent_qid == 0), question_order)
  for (.k in 1:nrow(.group_questions)) {
    .qid = .group_questions[.k,]$qid
    .title = .group_questions[.k,]$title

    # catch question
    # TODO if source_text exists, only append text_id
    .question = .group_questions[.k,]$question
    if (trimws(.question) != "") {
      .df_row_questionn = data.frame(paste0(.title, "___question"), .question, "")
      names(.df_row_questionn) = .col_names
      catalogue = rbind(catalogue, .df_row_questionn)
    }

    # catch help
    # TODO if source_text exists, only append text_id
    .help = questions[.k,]$help
    if (!is.na(.help) && trimws(.help) != "") {
      .df_row_help = data.frame(paste0(.title, "___help"), .help, "")
      names(.df_row_help) = .col_names
      catalogue = rbind(catalogue, .df_row_help)
    }

    # answer options
    if (.group_questions[.k,]$type %in% c("L", "!", "F")) {
      # TODO don't request answer options from server if already present
      #if (is.null(answer_options[[.qid]])) {
        .current_answer_options = ls_getAnswerOptions(questionID = .qid, lang = lang)
        #append(answer_options, list(.qid = current_answer_options))
      #}
      if (nrow(.current_answer_options) > 0) for (.m in 1:nrow(.current_answer_options)) {
        .answer_code = paste0(.title, "___AO___", .current_answer_options[.m,]$answerCode)

        # catch answer option
        .answer_text = .current_answer_options[.m,]$answerText
        if (!is.na(.answer_text) && trimws(.answer_text) != "") {
          .df_row_answer_text = data.frame(paste0(.answer_code, "___answer_text"), .answer_text, "")
          names(.df_row_answer_text) = .col_names
          catalogue = rbind(catalogue, .df_row_answer_text)
        }
      }
    }

    # are there sub-questions?
    .sub_questions = arrange(filter(questions, parent_qid == .qid), question_order)
    if (nrow(.sub_questions) > 0) for (.l in 1:nrow(.sub_questions)) {
      .sq_title = paste0(.title, "___SQ___", .sub_questions[.l,]$title)

      # catch sub-question
      .sub_question = .sub_questions[.l,]$question
      if (!is.na(.sub_question) && trimws(.sub_question) != "") {
        .df_row_sub_question = data.frame(paste0(.sq_title, "___sub_question"), .sub_question, "")
        names(.df_row_sub_question) = .col_names
        catalogue = rbind(catalogue, .df_row_sub_question)
      }
    }

    # TODO question validation tips and other translatables from question properties
    # TODO other_replace_text (manually)
  }
}
```


## Get answer options for each "L" type question

```{r}
# Type "L" seems to be the question type for lists, those own answer options
filter(questions, type == "L")[,"qid"]

ls_getAnswerOptions("170", lang = lang)
```

## Export the catalogue data frame to Excel file

```{r}
if (!require("writexl")) install.packages("writexl")
library(writexl)
write_xlsx(catalogue, "./catalogue/catalogue.xlsx") # cwd = vignettes
# NOTE that to avoid confusion whether translation texts should be replaced or appended,
# we could lock: Excel > Review tab > Protection
# Check "Format cells..." with target text column marked: uncheck cell protection
```

